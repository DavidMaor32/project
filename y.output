Terminals which are not used

   IF
   ELSE
   WHILE
   DO
   FOR
   STRLEN
   PUBLIC
   PRIVATE
   ARGS
   STATIC
   MAIN
   RETURN
   VOID
   AND
   EQ
   GRTR
   GRTR_EQ
   LESS
   LESS_EQ
   NOT
   NOT_EQ
   OR
   DIV
   MINUS
   PLUS
   MUL
   DEREF
   REF
   BLOCK_OPEN
   BLOCK_CLOSE
   PARENT_OPEN
   PARENT_CLOSE
   INDEX_OPEN
   INDEX_CLOSE
   NULLPTR
   P_INT
   P_FLOAT
   P_REAL
   P_CHAR


Grammar

    0 $accept: s $end

    1 s: program

    2 program: dec

    3 literal: LIT_BOOL
    4        | LIT_CHAR
    5        | LIT_REAL
    6        | LIT_FLOAT
    7        | LIT_INT
    8        | LIT_STRING

    9 value: literal
   10      | ID

   11 type: BOOL
   12     | CHAR
   13     | STRING
   14     | INT
   15     | FLOAT
   16     | REAL

   17 dec: declr_vars
   18    | dec declr_vars

   19 declr_vars: VAR type COLON ID ass vars SEMICOL

   20 vars: vars COMMA ID ass
   21     | /* empty */

   22 ass: ASS value
   23    | /* empty */


Terminals, with rules where they appear

$end (0) 0
error (256)
IF (258)
ELSE (259)
WHILE (260)
DO (261)
FOR (262)
ID (263) 10 19 20
STRLEN (264)
VAR (265) 19
ASS (266) 22
PUBLIC (267)
PRIVATE (268)
ARGS (269)
STATIC (270)
MAIN (271)
RETURN (272)
VOID (273)
AND (274)
EQ (275)
GRTR (276)
GRTR_EQ (277)
LESS (278)
LESS_EQ (279)
NOT (280)
NOT_EQ (281)
OR (282)
DIV (283)
MINUS (284)
PLUS (285)
MUL (286)
DEREF (287)
REF (288)
COLON (289) 19
SEMICOL (290) 19
COMMA (291) 20
BLOCK_OPEN (292)
BLOCK_CLOSE (293)
PARENT_OPEN (294)
PARENT_CLOSE (295)
INDEX_OPEN (296)
INDEX_CLOSE (297)
LIT_INT (298) 7
INT (299) 14
LIT_FLOAT (300) 6
FLOAT (301) 15
LIT_REAL (302) 5
REAL (303) 16
LIT_CHAR (304) 4
CHAR (305) 12
LIT_BOOL (306) 3
BOOL (307) 11
NULLPTR (308)
P_INT (309)
P_FLOAT (310)
P_REAL (311)
P_CHAR (312)
LIT_STRING (313) 8
STRING (314) 13


Nonterminals, with rules where they appear

$accept (60)
    on left: 0
s (61)
    on left: 1, on right: 0
program (62)
    on left: 2, on right: 1
literal (63)
    on left: 3 4 5 6 7 8, on right: 9
value (64)
    on left: 9 10, on right: 22
type (65)
    on left: 11 12 13 14 15 16, on right: 19
dec (66)
    on left: 17 18, on right: 2 18
declr_vars (67)
    on left: 19, on right: 17 18
vars (68)
    on left: 20 21, on right: 19 20
ass (69)
    on left: 22 23, on right: 19 20


state 0

    0 $accept: . s $end

    VAR  shift, and go to state 1

    s           go to state 2
    program     go to state 3
    dec         go to state 4
    declr_vars  go to state 5


state 1

   19 declr_vars: VAR . type COLON ID ass vars SEMICOL

    INT     shift, and go to state 6
    FLOAT   shift, and go to state 7
    REAL    shift, and go to state 8
    CHAR    shift, and go to state 9
    BOOL    shift, and go to state 10
    STRING  shift, and go to state 11

    type  go to state 12


state 2

    0 $accept: s . $end

    $end  shift, and go to state 13


state 3

    1 s: program .

    $default  reduce using rule 1 (s)


state 4

    2 program: dec .
   18 dec: dec . declr_vars

    VAR  shift, and go to state 1

    $default  reduce using rule 2 (program)

    declr_vars  go to state 14


state 5

   17 dec: declr_vars .

    $default  reduce using rule 17 (dec)


state 6

   14 type: INT .

    $default  reduce using rule 14 (type)


state 7

   15 type: FLOAT .

    $default  reduce using rule 15 (type)


state 8

   16 type: REAL .

    $default  reduce using rule 16 (type)


state 9

   12 type: CHAR .

    $default  reduce using rule 12 (type)


state 10

   11 type: BOOL .

    $default  reduce using rule 11 (type)


state 11

   13 type: STRING .

    $default  reduce using rule 13 (type)


state 12

   19 declr_vars: VAR type . COLON ID ass vars SEMICOL

    COLON  shift, and go to state 15


state 13

    0 $accept: s $end .

    $default  accept


state 14

   18 dec: dec declr_vars .

    $default  reduce using rule 18 (dec)


state 15

   19 declr_vars: VAR type COLON . ID ass vars SEMICOL

    ID  shift, and go to state 16


state 16

   19 declr_vars: VAR type COLON ID . ass vars SEMICOL

    ASS  shift, and go to state 17

    $default  reduce using rule 23 (ass)

    ass  go to state 18


state 17

   22 ass: ASS . value

    ID          shift, and go to state 19
    LIT_INT     shift, and go to state 20
    LIT_FLOAT   shift, and go to state 21
    LIT_REAL    shift, and go to state 22
    LIT_CHAR    shift, and go to state 23
    LIT_BOOL    shift, and go to state 24
    LIT_STRING  shift, and go to state 25

    literal  go to state 26
    value    go to state 27


state 18

   19 declr_vars: VAR type COLON ID ass . vars SEMICOL

    $default  reduce using rule 21 (vars)

    vars  go to state 28


state 19

   10 value: ID .

    $default  reduce using rule 10 (value)


state 20

    7 literal: LIT_INT .

    $default  reduce using rule 7 (literal)


state 21

    6 literal: LIT_FLOAT .

    $default  reduce using rule 6 (literal)


state 22

    5 literal: LIT_REAL .

    $default  reduce using rule 5 (literal)


state 23

    4 literal: LIT_CHAR .

    $default  reduce using rule 4 (literal)


state 24

    3 literal: LIT_BOOL .

    $default  reduce using rule 3 (literal)


state 25

    8 literal: LIT_STRING .

    $default  reduce using rule 8 (literal)


state 26

    9 value: literal .

    $default  reduce using rule 9 (value)


state 27

   22 ass: ASS value .

    $default  reduce using rule 22 (ass)


state 28

   19 declr_vars: VAR type COLON ID ass vars . SEMICOL
   20 vars: vars . COMMA ID ass

    SEMICOL  shift, and go to state 29
    COMMA    shift, and go to state 30


state 29

   19 declr_vars: VAR type COLON ID ass vars SEMICOL .

    $default  reduce using rule 19 (declr_vars)


state 30

   20 vars: vars COMMA . ID ass

    ID  shift, and go to state 31


state 31

   20 vars: vars COMMA ID . ass

    ASS  shift, and go to state 17

    $default  reduce using rule 23 (ass)

    ass  go to state 32


state 32

   20 vars: vars COMMA ID ass .

    $default  reduce using rule 20 (vars)
